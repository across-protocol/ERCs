---
eip: 7683
title: Cross Chain Intents
description: An interface for cross-chain trade execution systems.
author: Mark Toda (@marktoda), Matt Rice (@mrice32), Nick Pai (@nicholaspai)
discussions-to: https://ethereum-magicians.org/t/erc-cross-chain-intents-standard/19619
status: Draft
type: Standards Track
category: ERC
created: 2024-04-11
---

## Abstract

The following standard allows for the implementation of a standard API for cross-chain value-transfer systems. This standard provides generic order structs, as well as a standard set of settlement smart contract interfaces.

## Motivation

Intent-based systems have become the preeminent solution for end-user cross-chain interaction by abstracting away the complexity and time constraints of traditional bridges. One of the key difficulties for cross-chain intents systems is accessing sufficient liquidity and a network of active fillers across chains. This challenge may be exacerbated as the number of distinct chains increases over time. The end result of this is a poor experience for users including higher costs, longer wait times and higher failure rates than necessary.

By implementing a standard, cross-chain intents systems can interoperate and share infrastructure such as order dissemination services and filler networks, thereby improving end-user experience by increasing competition for fulfilling user intents.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

### Order structs

A compliant cross-chain order type MUST be ABI decodable into either `GaslessCrossChainOrder` or `OnchainCrossChainOrder` type.

```solidity
/// @title GaslessCrossChainOrder CrossChainOrder type
/// @notice Standard order struct to be signed by users, disseminated to fillers, and submitted to settlement contracts
struct GaslessCrossChainOrder {
	/// @dev The contract address that the order is meant to be settled by.
	/// Fillers send this order to this contract address on the origin chain
	address settlementContract;
	/// @dev The address of the user who is initiating the swap,
	/// whose input tokens will be taken and escrowed
	address user;
	/// @dev Nonce to be used as replay protection for the order
	uint256 nonce;
	/// @dev The chainId of the origin chain
	uint32 originChainId;
	/// @dev The timestamp by which the order must be initiated
	uint32 initiateDeadline;
	/// @dev The timestamp by which the order must be filled on the destination chain
	uint32 fillDeadline;
	/// @dev Arbitrary implementation-specific data
	/// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,
	/// or any other order-type specific information
	bytes orderData;
}

/// @title OnchainCrossChainOrder CrossChainOrder type
/// @notice Standard order struct for user-initiated orders, where the user is the msg.sender.
struct OnchainCrossChainOrder {
	/// @dev The timestamp by which the order must be initiated
	uint32 initiateDeadline;
	/// @dev The chainId of the origin chain
	uint32 originChainId;
	/// @dev The timestamp by which the order must be filled on the destination chain
	uint32 fillDeadline;
	/// @dev Arbitrary implementation-specific data
	/// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,
	/// or any other order-type specific information
	bytes orderData;
}
```

Cross-chain execution systems implementing this standard SHOULD use a sub-type that can be parsed from the arbitrary `orderData` field. This may include information such as the tokens involved in the transfer, the destination chain IDs, fulfillment constraints or settlement oracles.

All sub-types SHOULD be registered at github.com/erc-7683/order-subtypes to encourage sharing of sub-types based on their functionality.

### Decoding cross-chain orders

A compliant cross-chain order type MUST be convertible into the `ResolvedCrossChainOrder` struct. This means that the `orderData` must be decoded into the information needed to populate the `ResolvedCrossChainOrder` struct. Additionally, `orderData` SHOULD be decodable into a sub-type, which can be used for further functionality such as cross-chain calldata execution. It is the responsibility of the `user` and the `filler` to ensure that the `settlementContract` supports their order's contained sub-type. For example, there might be a sub-type called `Message`, which is defined by the following structs:

```solidity
// The Message subtype allows ERC7683 intents to carry calldata that is executed on a target contract on the destination chain. The settlement contract that the filler interacts with on the destination chain will decode the message into smart contract calls and execute the calls within the filler's `fill()` transaction.

// The Message contains calls that the user wants executed on the destination chain.
// The target is a contract on the destination chain that the settlement contract will attempt to send callData and value to.
struct Calls {
  address target;
  bytes callData;
  uint256 value;
}

// A fallbackRecipient can be set by the user in case sending the callData to the target reverts and the user still wants to guarantee that they receive their value to an EOA
// on the destination chain.
struct Message {
  Calls[] calls;
  address fallbackRecipient;
}
```

The `Message` sub-type is designed to be used by a 7683 user to incentivize a filler to to execute arbitrary calldata on a target destination chain contracton the user's behalf. For example, the settlement contract might decode the `orderData` containing the message information as follows:

```solidity
function fill(bytes32 orderId, bytes calldata originData, bytes calldata fillerData) public {
	(
		address user,
		uint32 fillDeadline,
		Output memory fillerOutput,
		Message memory message
	) = abi.decode(originData);

	// ...Do some preprocessing on the parameters here to validate the order...

	// ...Execute the fill logic of the ResolvedCrossChainOrder...

	// Handle the Message subtype:

        // If there is no fallback recipient, call and revert if the inner call fails.
        if (message.fallbackRecipient == address(0)) {
            this.attemptCalls(message.calls);
            return;
        }

        // Otherwise, try the call and send to the fallback recipient if any tokens are leftover.
        (bool success, ) = address(this).call(abi.encodeCall(this.attemptCalls, (message.calls)));
        if (!success) emit CallsFailed(message.calls, message.fallbackRecipient);

        // If there are leftover tokens, send them to the fallback recipient regardless of execution success.
        _drainRemainingTokens(token, payable(message.fallbackRecipient));
    }

    function attemptCalls(Call[] memory calls) external onlySelf {
        uint256 length = calls.length;
        for (uint256 i = 0; i < length; ++i) {
            Call memory call = calls[i];

            // If we are calling an EOA with calldata, assume target was incorrectly specified and revert.
            if (call.callData.length > 0 && call.target.code.length == 0) {
                revert InvalidCall(i, calls);
            }

            (bool success, ) = call.target.call{ value: call.value }(call.callData);
            if (!success) revert CallReverted(i, calls);
        }
    }

    function _drainRemainingTokens(address token, address payable destination) internal {
        if (token != address(0)) {
            // ERC20 token.
            uint256 amount = IERC20(token).balanceOf(address(this));
            if (amount > 0) {
                IERC20(token).safeTransfer(destination, amount);
                emit DrainedTokens(destination, token, amount);
            }
        } else {
            // Send native token
            uint256 amount = address(this).balance;
            if (amount > 0) {
                destination.sendValue(amount);
            }
        }
    }
```

### ResolvedCrossChainOrder struct

A compliant cross-chain order type MUST be convertible into the `ResolvedCrossChainOrder` struct.

```solidity
/// @title ResolvedCrossChainOrder type
/// @notice An implementation-generic representation of an order
/// @dev Defines all requirements for filling an order by unbundling the implementation-specific orderData.
/// @dev Intended to improve integration generalization by allowing fillers to compute the exact input and output information of any order
struct ResolvedCrossChainOrder {
	/// @dev The address of the user who is initiating the transfer
	address user;
	/// @dev The chainId of the origin chain
	uint32 originChainId;
	/// @dev The timestamp by which the order must be initiated
	uint32 initiateDeadline;
	/// @dev The timestamp by which the order must be filled on the destination chain(s)
	uint32 fillDeadline;

	/// @dev The inputs to be taken from the user as part of order initiation
	Input[] userInputs;
	/// @dev The outputs to be given to the user as part of order fulfillment
	Output[] maxOutputs;
	/// @dev The outputs to be given to the filler as part of order settlement
	Output[] minFillerOutputs;
}

/// @notice Tokens sent by the user as inputs to the order
struct Input {
	/// @dev The address of the ERC20 token on the origin chain
	address token;
	/// @dev The amount of the token to be sent
	uint256 amount;
}

/// @notice Tokens that must be receive for a valid order fulfillment
struct Output {
	/// @dev The address of the ERC20 token on the destination chain
	/// @dev address(0) used as a sentinel for the native token
	bytes32 token;
	/// @dev The amount of the token to be sent
	uint256 amount;
	/// @dev The address to receive the output tokens
	bytes32 recipient;
	/// @dev The destination chain for this output
	uint32 chainId;
}
```

### Initiated event

A compliant `Initiated` event MUST adhere to the following abi:

```solidity
/// @title FillInstructions type
/// @notice Instructions to parameterize each leg of the fill
/// @dev Provides all the origin-generated information required to produce a valid fill leg
struct FillInstructions {
	/// @dev The contract address that the order is meant to be settled by
	uint32 destinationChainId;
	/// @dev The contract address that the order is meant to be filled on
	bytes32 destinationSettler;
	/// @dev The data generated on the origin chain necessary to inform the fill
	bytes originData;
}

/// @notice Signals that an order has been initiated
/// @param orderId a unique order identifier within this settlement system
/// @param fillInstructions Fill instructions to parameterize each leg of the fill
event Initiated(bytes32 indexed orderId, FillInstructions[] fillInstructions);
```

### Settlement interfaces

A compliant origin settlement contract implementation MUST implement the `IOriginSettler` interface:

```solidity
/// @title IOriginSettler
/// @notice Standard interface for settlement contracts on the origin chain
interface IOriginSettler {
	/// @notice Initiates the settlement of a gasless cross-chain order on behalf of a user.
	/// @dev To be called by the filler.
	/// @dev This method must emit the Initiated event
	/// @param order The GaslessCrossChainOrder definition
	/// @param signature The user's signature over the order
	/// @param fillerData Any filler-defined data required by the settler
	/// @returns fillInstructions instructions to parameterize all fill legs required by this order
	function initiateFor(GaslessCrossChainOrder order, bytes signature, bytes originFillerData) external returns (FillInstructions[]);

	/// @notice Initiates the settlement of a cross-chain order
	/// @dev To be called by the user
	/// @dev This method must emit the Initiated event
	/// @param order The OnchainCrossChainOrder definition
	/// @param signature The user's signature over the order
	/// @param fillerData Any filler-defined data required by the settler
	/// @returns fillInstructions instructions to parameterize all fill legs required by this order
	function initiate(OnchainCrossChainOrder order) external returns (FillInstructions[] fillInstructions);

	/// @notice Resolves a specific GaslessCrossChainOrder into a generic ResolvedCrossChainOrder
	/// @dev Intended to improve standardized integration of various order types and settlement contracts
	/// @param order The GaslessCrossChainOrder definition
	/// @param originFillerData Any filler-defined data required by the settler
	/// @returns ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order
	function resolveFor(GaslessCrossChainOrder order, bytes originFillerData) external view returns (ResolvedCrossChainOrder);

	/// @notice Resolves a specific OnchainCrossChainOrder into a generic ResolvedCrossChainOrder
	/// @dev Intended to improve standardized integration of various order types and settlement contracts
	/// @param order The OnchainCrossChainOrder definition
	/// @param fillerData Any filler-defined data required by the settler
	/// @returns ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order
	function resolve(OnchainCrossChainOrder order) external view returns (ResolvedCrossChainOrder);
}
```

A compliant destination settlement contract implementation MUST implement the `IDestinationSettler` interface:

```solidity
/// @title IDestinationSettler
/// @notice Standard interface for settlement contracts on the destination chain
interface IDestinationSettler {
	/// @notice Fills a single leg of a particular order on the destination chain
	/// @param orderId Unique order identifier for this order
	/// @param originData Data emitted on the origin to parameterize the fill
	/// @param fillerData Data provided by the filler to inform the fill or express their preferences
	function fill(bytes32 orderId, bytes calldata originData, bytes calldata fillerData) external;
}
```

Cross-chain execution systems implementing this standard SHOULD use a sub-type that can be parsed from the arbitrary `fillerData` field. This may include information such as the desired timing or form of payment for the filler

All sub-types SHOULD be registered at github.com/erc-7683/filler-data-subtypes to encourage sharing of sub-types based on their functionality.

### fillerData

## Rationale

### Generic OrderData

A key consideration is to ensure that a broad range of cross-chain intent designs can work within the same standard. To enable this, the specification is designed around a cross-chain intents *flow*, with two variations: gasless and onchain.

Gasless cross-chain intents flow:

1. The user signs an off-chain message defining the parameters of their order
2. The order is disseminated to fillers
3. The filler initiates the order on the origin chain
4. The filler fills the order on the destination chain
5. A cross-chain settlement process takes place to settle the order

Onchain cross-chain intents flow:

1. The user signs a transaction calling initiate with their order
2. The filler retrieves the emitted event
3. The filler fills the order on the destination chain
4. A cross-chain settlement process takes place to settle the order

Within this flow, implementers of the standard have design flexibility to customize behavior such as:

- Price resolution, e.g. dutch auctions (on origin or destination) or oracle-based pricing
- Fulfillment constraints
- Settlement procedures.

The `orderData` field allows implementations to take arbitrary specifications for these behaviors while still enabling integrators to parse the primary fields of the order.

This functionality also motivated the `resolve` view function and `ResolvedCrossChainOrder` type. Resolution enables integrating fillers to validate and assess orders without specific knowledge of the `orderData` field at hand.

### Emission of FillInstructions

An important component of the standard is creating a flexible and robust mechanism for fillers to ensure their fills are valid. For a fill to be valid,
it typically must satisfy the following constraints:
1. It must be filled on the correct destination chain(s)
2. It must be filled on the correct destination contract
3. It must include some (not necessarily all) information from the order that the user provided on the origin chain
4. It may require some execution information from the initiate call on the origin chain (ex. dutch auctions based on initiate timing)

1 & 2 could potentially be generated by a re-simulation of `resolve`. However, a filler must deeply understand the settlement system to determine
3 & 4. `FillInstructions` is intended to remove this burden from the filler, allowing them to rely on the origin settler contract to provide them
the information needed to both simulate and perform fills.

One may notice that the `originData` field within `FillInstructions` is completely opaque. This opaqueness allows the settler implementations to
freely customize the data they transmit. Because fillers do not need to interpret this information, the opaqueness does not result in any
additional implementation costs on fillers.

This functionality also makes it feasible for a user, filler, or order distribution system to perform an end-to-end simulation of the order initiation
and fill to evaluate all resulting state transitions without understanding the nuances of a particular execution system.

### Cross-compatibility

Since this standard is intended to reduce friction for users moving value across chains, non-EVM ecosystems should not be excluded. However, attempting
to pull each non-EVM ecosystem in would dramatically increase the size and complexity of this standard, while ommitting any that come in the future.

Instead, this standard is intended to be cross-compatible with other ecosystems. It standardizes interfaces and data types on EVM chains, but allows
for the creation of sibling standards that define compatible interfaces, data types, and flows within other ecosystems. Intents created within these
sibling standards should be able to be filled on an EVM chain and vice versa.

To ensure this cross-compatibility, all foreign addresses use `bytes32` rather than `address` to allow for larger address identifiers.

### Usage of Permit2

Permit2 is not specifically required by this standard, but does provide an efficient and straightforward approach to building standard-adherent protocols. Specifically, the `witness` functions of permit2 allow users to both approve the token transfer *and* the order itself with a single signature. This also nicely couples the transfer of tokens with a successful initiation of the order.

In contrast, a standard approval model would require two separate signatures - a token approval (either [ERC-2612](./eip-2612.md) or on-chain) and a signature to approve the terms of the order. It also decouples the token approval from the order, meaning approved tokens could potentially be taken at any time due to a buggy or untrusted settler contract.

When building a standard-compliant settler system around Permit2, the following considerations should be made

- `nonce` in the order struct should be a permit2 nonce
- `initiateDeadline` in the order struct should be the permit2 deadline
- A full order struct including the parsed `orderData` should be used as the witness type during the permit2 call. This ensures maximum transparency to the user as they sign their order permit.

## Security Considerations

<!-- TODO -->

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
